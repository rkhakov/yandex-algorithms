"""
ID: 69406344

ПРИНЦИП РАБОТЫ:
    * Определяем левую и правую границы, где левой будет первый элемент массива,
        а правой - последний
    * Вычисляем середину массива
    * Если центральный элемент массива равен искомому, возвращаем его индекс
    * Проверяем является ли левая часть массива отсортированной
        * Если левая часть отсортирована и искомый элемент находится в ней
        * Сдвигаем правую границу на -1 от середины и повторяем действия
        * Иначе ищем в правой границе
    * Если левая часть массива не отсортирована
        * Проверяем вхождение искомого элемента в правой части массива
        * Если элемент в правой части массива, сдвигаем левую границу на +1 от середины
        * Иначе ищем в противоположной половине (левой)

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
    Поиск в сдвинутом отсотрированном массиве
    Основным отличием данного алгоритма от бинарного поиска в остортированном массиве
    является то что тут элементы сдвинуты влево на k шагов
    Так как нам не известно на какое количество элементом сдвинут массив
    Мы так же как и при поиске в отсортированном массиве, находим середину массива.
    Проверяем входит ли искомый элемент в одну из сторон,
    если да, то ищем в ней это будет бинарный поиск в отсортированном массиве
    Если нет, то ищем в противоположной части массива повторяя те-же действия

ВРЕМЕННАЯ СЛОЖНОСТЬ:
    O(log n) - где n это количество элементов в массиве.
        Так как каждый раз массив сокращается в 2 раза то сложность получается log n

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
    O(1) - используются вспомагательные переменные left, right, mid
        которые будут использовать константную память
"""
from typing import List


def broken_search(nums: List[int], target: int) -> int:
    left = 0
    right = len(nums) - 1

    while left <= right:
        # https://ai.googleblog.com/2006/06/extra-extra-read-all-about-it-nearly.html
        mid = left + (right - left) // 2
        if nums[mid] == target:
            return mid

        if nums[left] <= nums[mid]:
            if nums[left] <= target <= nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] <= target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1
    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6
