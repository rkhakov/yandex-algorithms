"""
ID: 69421556

ПРИНЦИП РАБОТЫ:
    Создаем объект для каждого студента и помещаем его в массив.
    У каждого объекста добавлены магческие методы для сравнения объектов между собой
    В качетсве ключа для сравнения используем кортеж
    Так как сравнение кортежей идет последовательно, если первые элементы равны,
    то проверяется следующий и тд.

    Алогоритм сортировки: Quicksort in-place
    В данном алгоритме мы не создаем дополнительную память для результатов
    как при сортировке слиянием, а переставляем местами элементы в исходном массиве

    * Используем элемент правой границы в качестве опорного
    * Заводим дополнительную переменную "указатель" изначально равной левой границе
    * Проходимся по каждому элементу массива и если он меньше опрорного меняем местами
        с элементом на который указаывает указатель, и после перестановки инкрементируем
        указатель. Таким образом указатель всегда будет указывать на элемент больше
        опорного, и когда встретится элемент меньше опорного они поменяются местами
    * После прохождения по всем элементам массива кроме последнего, мы еще раз меняем
        элементы местами на которых указывает указатель и опорный (последний).
        Все элементы левее опорного будут меньше чем он, а справа больше чем опорный
    * Рекурсивно вызываем функцию сортировки для левой части массива
        1. От левой границы до индекса опорного элемента - 1
        2. Для правой части массива будет от индекса опорного элемента + 1,
          до правой границы
    * Рекурсия будет вызываться пока не наступит базовый случай
        (левая граница будет равна или больше чем правая)

ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ:
    Выбираем опорный элемент и перемещаем элементы меньше опорного в левую часть,
    в результате те элементы что больше опорного будут в правой части массива,
    а те что меньше в левой. Опорный элемент будет в центра массива.
    Затем повторяем эти действия по отдельности для элементов массива левее опорного
    и правее опорного
    Эти действия повторяются пока не наступит базовы случай рекурсии
    На выходе у нас получится отсортрованный массив


ВРЕМЕННАЯ СЛОЖНОСТЬ:
    Сложность работы алгоритма зависит от глубины рекурсии. На каждом уровне рекурсии,
    будет просиходить обход всех элементов массива O(n), количество уровней рекурсии
    зависит от изначального массива
    Худший случай: O(n^2) - где n это количество элементов в массиве.
        Квадратичная сложность будет если элементы массива уже отсортированы
        или все элементы равны.
        В таком случае одна из частей массива
        всегда будет пустой, а для другой части массива будет рекурсивно вызываться
        сортировка, каждый раз уменьшая количество элементов на 1
    Средний: O(n * log n) - где n это количество элементов в массиве.
        Глубина рекурсии в данном случае составит log n
        если массив будет разбиваться на примерно равные части
    Лучший: O(n * log n) - так же как и в среднем случае

    Добавление студентов в массив в среднем выполняется за константное время O(1)

ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ:
    Дополнительный массив для результата как при сортировки слиянием тут не используется
    Мы меняем исходный массив переставляя элементы местами
    Используются только несколько вспомагательных переменных,
    которые занимают константную пямять
    Но у нас есть рекурсия, вызовы которой сохраняются в стеке, поэтому использование
    памяти будет зависить от глубины рекурсии

    Худший случай: O(n) - n это количество элементов в массиве. Максимальная глубина
    стека если массив уже отсортрован или все элементы равны
    Средний: O(log n) - n также это количество элементов в массиве. На каждом вызове
    функции массив будет сокращаться в двое

"""
from typing import List, Any, NamedTuple, Optional


def qsort(arr: List[Any], left: int = 0, right: Optional[int] = None) -> None:
    if right is None:
        right = len(arr) - 1
    if left >= right:
        return

    def partition(left: int, right: int) -> int:
        pivot = arr[right]
        swap_pointer = left
        for i in range(left, right):
            if arr[i] < pivot:
                arr[swap_pointer], arr[i] = arr[i], arr[swap_pointer]
                swap_pointer += 1
        # меняем элемент с опорным
        # Он будет серединой между левой и правой частями массива
        # все элементы левее - будут меньше опорного, правее - больше
        arr[swap_pointer], arr[right] = arr[right], arr[swap_pointer]
        return swap_pointer

    mid_index = partition(left, right)
    qsort(arr, left, mid_index - 1)
    qsort(arr, mid_index + 1, right)


class Student(NamedTuple):
    name: str
    solved_tasks: int
    fines: int

    def cmp_key(self):
        """
        Условия сравнения:
            1. Максимальное кол-во решенных задач
            2. Минимальное кол-во штрафных баллов
            3. По имени студента
        """
        return (-self.solved_tasks, self.fines, self.name)

    def __lt__(self, other: "Student") -> bool:
        return self.cmp_key() < other.cmp_key() if isinstance(other, Student) else False

    def __gt__(self, other) -> bool:
        return self.cmp_key() > other.cmp_key() if isinstance(other, Student) else False

    def __eq__(self, other) -> bool:
        return self == other if isinstance(other, Student) else False


def main():
    students_count: int = int(input())
    students: List[Student] = []
    for _ in range(students_count):
        name, solved_tasks, fines = input().split()
        student = Student(name=name, solved_tasks=int(solved_tasks), fines=int(fines))
        students.append(student)

    qsort(students)
    for student in students:
        print(student.name)


if __name__ == "__main__":
    main()
